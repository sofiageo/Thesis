\chapter{Προγραμματιστικό περιβάλλον}
Στην παρακάτω ενότητα θα παρατηρήσουμε και θα αναλύσουμε τις ομοιότητες αλλά και τις διαφορές των προγραμματιστικών περιβαλλόντων. 
Το προγραμματιστικό περιβάλλον είναι ένα πολύ σημαντικό μέρος της υλοποίησης ενός προγράμματος που υποστηρίζει επιτάχυνση μέσω GPGPU, καθώς δίνει την δυνατότητα στον προγραμματιστή να αναπτύξει εφαρμογές με ταχύτητα αλλά και με έλεγχο των λαθών και των προβλημάτων που μπορεί να προκύψουν από αυτά.
\section{OpenCL - AMD}
Το AMD OpenCL Accelerated Parallel Processing (APP) είναι ένα σύνολο προχωρημένων τεχνολογιών υλικού και λογισμικού που ενεργοποιεί τους υπολογιστικούς πυρήνες μιας κάρτας γραφικών(GPU), ενώ εργάζεται σε αρμονία με τους πυρήνες του επεξεργαστή (CPU), για να εκτελέσει ετερογενώς και να επιταχύνει αρκετές εφαρμογές που δεν σχετίζονται μόνο με γραφικά.

\begin{figure}[h]
\centering
\includegraphics[scale=1]{IDEs/amd-app}
\caption{Λογότυπο AMD APP\cite{figure-29}}
\end{figure}

Αυτό επιτρέπει καλύτερα ισορροπημένες πλατφόρμες με δυνατότητα να εκτελούν απαιτητικά υπολογιστικά έργα πιο γρήγορα από ποτέ, και συντονίζει τους προγραμματιστές ώστε να βελτιστοποιήσουν τις εφαρμογές τους για εκτέλεση σε μονάδες επιτάχυνσης υπολογισμών (APUs). Το κιτ ανάπτυξης λογισμικού της AMD (SDK) είναι μια ολοκληρωμένη πλατφόρμα ανάπτυξης που έχει δημιουργηθεί από την AMD για να επιτρέψει την γρήγορη και εύκολη ανάπτυξη εφαρμογών με επιτάχυνση από τεχνολογία AMD APP. Το SDK περιέχει παραδείγματα, οδηγίες χρήσης, και άλλο υλικό ώστε να βοηθήσει τον προγραμματιστή να αναπτύξει υπολογισμούς με χρήση του OpenCL, Bolt, ή C++ AMP σε μια εφαρμογή C/C++, ή την χρήση Aparapi για μια Java εφαρμογή.

\section{Μετατροπή εφαρμογών από CUDA / OpenCL}
Αν έχουμε μια εφαρμογή που έχει ήδη γραφτεί σε C για CUDA, είναι απλή η διαδικασία μετατροπής σε OpenCL.\cite{ides-2} Το σημαντικό μέρος είναι να βρούμε το συντακτικό που χρησιμοποιείται και αντιστοιχεί στις ενσωματωμένες διαδικασίες του πυρήνα. Επίσης πρέπει να μετατρέψουμε τις κλήσεις API του CUDA σε αντίστοιχες κλήσεις του OpenCL. Μερικά θέματα που πρέπει να προσέχουμε:
\begin{itemize}
	\item Τα pointers στους πυρήνες OpenCL πρέπει να δηλώνονται με τον χώρο μνήμης. Για παράδειγμα, ένας pointer σε μια τοπική μνήμη θα δηλώνεται ώς \_\_local int* p; Αυτό ισχύει και σε παραμέτρους του πυρήνα: τα δεδομένα που περνάνε σε έναν πυρήνα είναι συνήθως σε πίνακες που αναπαρίστανται από \_\_global pointers.
	\item Το CUDA ενθαρρύνει την χρήση βαθμωτού κώδικα στους πυρήνες. Αν και αυτό λειτουργεί και στο OpenCL, ανάλογα την αρχιτεκτονική του συστήματος που θα εκτελεστεί ο πυρήνας, μπορεί να είναι πιο αποδοτικό να γράψουμε προγράμματα που να εκτελούνται σε τύπους vector, όπως το float4, σε αντίθεση με κάποιον καθαρά βαθμωτό τύπο. Αυτό είναι χρήσιμο και για τις κάρτες γραφικών αλλά και για τους επεξεργαστές της AMD, που μπορούν να λειτουργούν αποδοτικά σε τύπους vector. Το OpenCL παρέχει επίσης ευέλικτα πρωτόγονα για αποδοτική δημιουργία και επανασχεδιασμό τύπων vector.
	\item Το CUDA δεν παρέχει πλούσιες μηχανές για παραλληλισμό έργων, και για αυτό ίσως είναι καλύτερο να εκμεταλλευτούμε τις δυνατότητες του παραλληλισμού του OpenCL.
\end{itemize}

\subsection{Γενική Ορολογία}
\begin{table}[!htbp]
	\begin{tabular}{|p{8cm}|p{8cm}|}
	\hline 
	\rowcolor[HTML]{C0C0C0} 
	Ορολογία C για CUDA & Ορολογία OpenCL \\ \hline
	Thread & Work-item \\ \hline
	Thread block & Work-group \\ \hline
	Global memory & Global memory \\ \hline
	Constant memory & Constant memory \\ \hline
	Shared memory & Local memory \\ \hline
	Local memory & Private memory \\ \hline
	\end{tabular}
	\caption{Γενική Ορολογία - Για να περιγράψουμε υπολογισμούς και χώρους μνήμης σε C για CUDA και OpenCL. Αυτοί οι όροι είναι σχετικά παρόμοιοι μεταξύ τους και στα δύο συστήματα.}
\end{table}
\clearpage
\subsection{Γράφοντας πυρήνες - Qualifiers}
\begin{table}[!htbp]
	\begin{tabular}{|p{8cm}|p{8cm}|}
	\hline 
	\rowcolor[HTML]{C0C0C0} 
	Ορολογία C για CUDA & Ορολογία OpenCL \\ \hline
	\_\_global\_\_ function (κλήση από τον ξενιστή (host), όχι από την συσκευή) & \_\_kernel function (κλήση από συσκευή, συμπεριλαμβάνει CPU) \\ \hline
	\_\_device\_\_ function (δεν καλείται από τον ξενιστή) & Δεν χρειάζεται δήλωση \\ \hline
	\_\_constant\_\_ δήλωση μεταβλητής & \_\_constant δήλωση μεταβλητής \\ \hline
	\_\_device\_\_ δήλωση μεταβλητής & \_\_global δήλωση μεταβλητής \\ \hline
	\_\_shared\_\_ δήλωση μεταβλητής & \_\_local δήλωση μεταβλητής \\ \hline
	\end{tabular}
	\caption{Qualifiers για διαδικασίες πυρήνα — δείχνει τους qualifiers που προστίθενται στις διαδικασίες και δεδομένα  όταν γράφουμε πυρήνες σε CUDA και OpenCL. Η μεγαλύτερη διαφορά ανάμεσα σε αυτά τα δύο είναι ότι στο CUDA, οι \_\_global\_\_ διαδικασίες είναι σημεία εκκίνησης της GPU, και οι \_\_device\_\_ διαδικασίες εκτελούνται στην συσκευή, αλλά δεν μπορούν να κληθούν από τον ξενιστή (host). Στο OpenCL, οι διαδικασίες σημείων εκκίνησης δηλώνονται με το \_\_kernel qualifier, αλλά οι διαδικασίες σημείων μη εκκίνησης δεν χρειάζονται να δηλωθούν.}
\end{table}
\clearpage
\subsection{Γράφοντας πυρήνες - Indexing}
\begin{table}[!htbp]
	\begin{tabular}{|p{8cm}|p{8cm}|}
	\hline 
	\rowcolor[HTML]{C0C0C0} 
	Ορολογία C για CUDA & Ορολογία OpenCL \\ \hline
	gridDim & get\_num\_groups() \\ \hline
	blockDim &get\_local\_size() \\ \hline
	blockIdx & get\_group\_id() \\ \hline
	threadIdx &get\_local\_id \\ \hline
	Δεν υπάρχει άμεσα ισοδύναμο. Συνδυάζει τα blockDim, blockIdx, και threadIdx για να υπολογίσει ένα global index. & get\_global\_id() \\ \hline
	Δεν υπάρχει άμεσα ισοδύναμο. Συνδυάζει τα gridDim και blockDim για να υπολογίσει το global size. & get\_global\_size() \\ \hline
	\end{tabular}
	\caption{Διαδικασίες Indexing για χρήση σε πυρήνες - Ο πίνακας δείχνει τους διάφορους μηχανισμούς indexing που παρέχονται από το CUDA και το OpenCL. Το CUDA παρέχει πυρήνες indexing μέσω ειδικών δηλωμένων μεταβλητών, ενώ το OpenCL παρέχει τις αντίστοιχες πληροφορίες μέσω κλήσεων διαδικασιών. Το OpenCL επίσης παρέχει πληροφορίες global indexing, ενώ το CUDA απαιτεί χειροκίνητους υπολογισμούς των global indices.}
\end{table}
\clearpage
\subsection{Γράφοντας πυρήνες - Synchronization}
\begin{table}[!htbp]
	\begin{tabular}{|p{8cm}|p{8cm}|}
	\hline 
	\rowcolor[HTML]{C0C0C0} 
	Ορολογία C για CUDA & Ορολογία OpenCL \\ \hline
	\_\_syncthreads() & barrier() \\ \hline
	\_\_threadfence() & Δεν υπάρχει άμεσα ισοδύναμο. \\ \hline
	\_\_threadfence\_block() & mem\_fence(CLK\_GLOBAL\_MEM\_FENCE | CLK\_LOCAL\_MEM\_FENCE) \\ \hline
	Δεν υπάρχει άμεσα ισοδύναμο. & read\_mem\_fence() \\ \hline
	Δεν υπάρχει άμεσα ισοδύναμο. & write\_mem\_fence()	 \\ \hline
	\end{tabular}
	\caption{Διαδικασίες συγχρονισμού για χρήση σε διαδικασίες πυρήνα - Ο πίνακας δείχνει διαδικασίες που παρέχονται για τον συγχρονισμό σε διαδικασίες πυρήνα. Τα \_\_syncthreads() και barrier() παρέχουν ένα μηχανισμό για συγχρονισμό όλων των αντικειμένων εργασίας σε μια ομάδα εργασίας, όπου η κλήση διαδικασιών σταματάει την εκτέλεση μέχρι όλα τα αντικείμενα εργασίας να καλέσουν το barrier.}
\end{table}
\clearpage
\subsection{Σημαντικά αντικείμενα API}
\begin{table}[!htbp]
	\begin{tabular}{|p{8cm}|p{8cm}|}
	\hline 
	\rowcolor[HTML]{C0C0C0} 
	Ορολογία C για CUDA & Ορολογία OpenCL \\ \hline
	CUdevice & cl\_device\_id \\ \hline
	CUcontext & cl\_context \\ \hline
	CUmodule & cl\_program \\ \hline
	CUfunction & cl\_kernel \\ \hline
	CUdeviceptr & cl\_mem \\ \hline
	Δεν υπάρχει άμεσα ισοδύναμο. Η πιο κοντινή προσέγγιση θα είναι ο μηχανισμός Stream του CUDA. & cl\_command\_queue \\ \hline
	\end{tabular}
	\caption{Επιλεγμένα αντικείμενα API για χρήση στον κώδικα του ξενιστή(host) — Ο πίνακας δείχνει μερικά αντικείμενα που παρέχονται από τα αντίστοιχα APIs, τα οποία χρησιμοποιούνται στον κώδικα του ξενιστή για να ελέγξουν την εκτέλεση σε διάφορες συσκευές, να διαχειριστούν δεδομένα, κτλπ. Άξιο σημείωσης είναι το cl\_command\_queue, που παρέχει δυνατότητες παραλληλισμού εργασιών του OpenCL, επιτρέποντας στον προγραμματιστή να δηλώνει εξαρτήσεις μεταξύ έργων που εκτελούνται σε μια συσκευή. Το CUDA δεν παρέχει αυτήν την ευελιξία. – Ο πιο κοντινός μηχανισμός που παρέχει το CUDA είναι ο μηχανισμός Stream, που επιτρέπει στις συναλλαγές πυρήνα και μνήμης να τοποθετούνται σε ανεξάρτητα streams. Αυτό δεν είναι τόσο γενικό όσο η δυνατότητα παραλληλισμού έργων που παρέχει η Ουρά Εντολών του OpenCL, γιατί δεν επιτρέπει παραλληλισμό μέσα στην ουρά, και ο συγχρονισμός μέσα στα streams είναι δύσκολος, ενώ η Ουρά Εντολών παρέχει παραλληλισμό μέσα και ενδιάμεσα στις ουρές, αλλά και ευέλικτες δυνατότητες συγχρονισμού μέσω των OpenCL γεγονότων (events).}
\end{table}
\clearpage
\subsection{Σημαντικές κλήσεις API}
\begin{table}[!htbp]
	\begin{tabular}{|p{8cm}|p{8cm}|}
	\hline 
	\rowcolor[HTML]{C0C0C0} 
	Ορολογία C για CUDA & Ορολογία OpenCL \\ \hline
	cuInit() & Δεν απαιτείται αρχικοποίηση OpenCL \\ \hline
	cuDeviceGet() & clGetContextInfo() \\ \hline
	cuCtxCreate() & clCreateContextFromType() \\ \hline
	Δεν υπάρχει άμεσα ισοδύναμο. & clCreateCommandQueue() \\ \hline
	cuModuleLoad() [απαιτείται εκτελέσιμο αρχείο] & clCreateProgramWithSource() ή clCreateProgramWithBinary() \\ \hline
	Δεν υπάρχει άμεσα ισοδύναμο. Τα προγράμματα CUDA συνθέτονται ξεχωριστά & clBuildProgram() \\ \hline
	\end{tabular}
	\caption{Επιλεγμένες κλήσεις API που χρησιμοποιούνται σε κώδικα του ξενιστή (Host) - Ο πίνακας καταγράφει κάποιες από τις σημαντικές API κλήσεις που χρησιμοποιούνται σε κώδικα του ξενιστήγια να καθορίσουν και να εκτελέσουν παράλληλους υπολογισμούς, όπως επίσης και να διαχειριστούν δεδομένα σε υπολογιστικές συσκευές. Για το μεγαλύτερο μέρος, αυτές οι διαδικασίες είναι σχεδόν ίδιες, αν και μερικές φορές η λειτουργικότητα διαχωρίζεται κάπως διαφορετικά, όπως φαίνεται και από τον πίνακα. Η μεγαλύτερη διαφορά είναι ότι το OpenCL έχει ένα μοντέλο σύνθεσης εκτέλεσης αλλά επιτρέπει στα προγράμματα να συνθέτονται ξεχωριστά, ενώ το CUDA επιτρέπει μόνο ξεχωριστή σύνθεση των προγραμμάτων. Για να εξομοιώσουν αυτήν την λειτουργία στο OpenCL, οι προγραμματιστές μπορούν να χρησιμοποιήσουν την κλήση API clGetProgramInfo() για να ανακτήσουν ένα εκτελέσιμο αρχείο κια να το σώσουν για επόμενη χρήση, μαζί με την κλήση clCreateProgramWithBinary() για να δημιουργηθεί ένα αντικείμενο OpenCL από ένα εκτελέσιμο αρχείο. }
\end{table}

\section{Συγγραφή Java - JOCL}
H χρήση της Java και των βιβλιοθηκών που επιτρέπουν εκτέλεση OpenCL, έχει το βασικό πλεονέκτημα της παροχής διευκολύνσεων προς τους προγραμματιστές, αφού τους παρέχει με ένα μοντέλο προγραμματισμού υψηλού επιπέδου, αναλαμβάνοντας την αυτόματη μετάφραση σε εντολές χαμηλού επιπέδου με σκοπό την εκτέλεση των προγραμμάτων σε GPU.

Πρέπει να κατανοήσουμε πλήρως ότι δεν μπορεί να εκτελεστεί κώδικας Java στην GPU. Αυτός ο κώδικας μεταφράζεται στο υποσύνολο εντολών του OpenCL. Ο κώδικας OpenCL δεν έχει άμεση πρόσβαση στα δεδομένα του Java κώδικα. Σε πολλές περιπτώσεις, ο κώδικας OpenCL μοιάζει με την χρήση SQL. Δημιουργούμε μια ρουτίνα και δεσμεύουμε παραμέτρους από το πρόγραμμα Java προς το OpenCL.\cite{ides-3} Τέλος, ανακτούμε τα δεδομένα από την ρουτίνα OpenCL πίσω στο αρχικό μας πρόγραμμα. Αυτή η διαδικασία μοιάζει με την χρήση μιας βάσης μέσω SQL.
\begin{figure}[h]
\centering
\includegraphics[width=0.5\linewidth]{IDEs/netbeans-logo}
\caption{Λογότυπο Netbeans IDE\cite{figure-28}}
\end{figure}

Το JOCL (Java bindings for OpenCL) παρέχει Java-bindings για το OpenCL που έχουν αρκετές ομοιότητες με το κανονικό OpenCL API. Οι διαδικασίες παρέχονται ως στατικές μέθοδοι, και οι ορολογίες και οι υπογραφές αυτών των μεθόδων έχουν διατηρηθεί, εκτός από πολύ ειδικές περιπτώσεις όπως εντολές που έχουν ίδια ονομασία στην Java.

Για την συγγραφή προγραμμάτων OpenCL αλλά και CUDA σε Java, χρησιμοποιούμε ένα περιβάλλον προγραμματισμού όπως το Netbeans. Το Netbeans μας παρέχει σύγχρονα εργαλεία προγραμματισμού και ένα πολύ ευέλικτο σύστημα διαχείρησης εξαρτήσεων (Maven) με το οποίο μπορούμε να εγκαταστήσουμε πολύ εύκολα το JOCL αλλά και τις υπόλοιπες εξαρτήσεις του προγράμματος μας.

Παράδειγμα χρήσης του Netbeans για συγγραφή προγραμμάτων OpenCL μπορούμε να δούμε στην παρακάτω εικόνα.
\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{IDEs/JOCL}
\caption{Παράδειγμα χρήσης Netbeans IDE για συγγραφή κώδικα OpenCL}
\end{figure}

\section{Ανάλυση και εντοπισμός σφαλμάτων - CodeXL}
Το AMD CodeXL είναι μια σουίτα εργαλείων που επιτρέπει στους προγραμματιστές να απολαύσουν τα οφέλη των επεξεργαστών AMD (CPU), των GPU, αλλά και των APU. Περιέχει πολύ δυνατά εργαλεία εντοπισμού σφαλμάτων, δυνατότητες ανάλυσης στατικού πυρήνα OpenCL, ενισχύει την πρόσβαση των προγραμματιστών στην εποχή του ετερογενούς υπολογισμού. Το AMD CodeXL παρέχεται σαν ξεχωριστή εφαρμογή είτε σαν πρόσθετο του Visual Studio για Windows.

\subsection{GPU Debugging}
Το AMD CodeXL παρέχει αναλυτικές δυνατότητες εντοπισμού σφαλμάτων OpenCL και OpenGL και πυρήνων OpenCL. Ο εντοπισμός σφαλμάτων περιλαμβάνει εντοπισμό πραγματικού χρόνου πυρήνων, το οποίο επιτρέπει στους προγραμματιστές να εισέλθουν στην εκτέλεση του πυρήνα άμεσα από τις κλήσεις API, να ανακτήσουν τις τιμές των μεταβλητών για τις διαφορετικές ομάδες εργασίας, να λύσουν τα προβλήματα που εντοπίστηκαν, και όλα αυτά σε έναν υπολογιστή με μια μονάδα επεξεργασίας γραφικών (GPU).

\subsection{Ανάλυση στατικού πυρήνα}
Το AMD CodeXL περιέχει έναν αναλυτή στατικού πυρήνα που επιτρέπει στους προγραμματιστές να συνθέσουν, να αναλύσουν και να αποσυναρμολογήσουν τον δικό τους κώδικα πυρήνα OpenCL, να εκτιμήσουν την ακριβής επίδοση των πυρήνων και να δουν το σύνολο της εφαρμογής, χωρίς να χρειαστεί να την εκτελέσουν.

Παράδειγμα χρήσης του CodeXL φαίνεται στην παρακάτω εικόνα.
\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{IDEs/AMD-CODEXL}
\caption{Παράδειγμα χρήσης AMD CodeXL για ανάλυση κώδικα OpenCL}
\end{figure}

\section{Συγγραφή OpenCL - CUDA}
To Nvidia Nsight είναι η πιο ολοκληρωμένη πλατφόρμα για ετερογενή προγραμματισμό. Μας παρέχει δυνατά εργαλεία εντοπισμού σφαλμάτων και δημιουργίας προφιλ τα οποία επιτρέπουν την βελτιστοποίηση της απόδοσης στην CPU και GPU. Όχι μόνο αυτά τα εργαλεία βελτιστοποιούν την απόδοση, αλλά μας βοηθάνε να αποκτήσουμε καλύτερη κατανόηση του κώδικα μας, να εντοπίσουμε και να αναλύσουμε προβλήματα απόδοσης και να παρατηρήσουμε την συμπεριφορά όλων των δραστηριοτήτων. \cite{ides-4}

Το Nvidia Nsight παρέχεται ως πρόσθετο στην πλατφόρμα προγραμματισμού Visual Studio. Μας δίνει αρκετές χρήσιμες δυνατότητες όπως:
\begin{itemize}
\item Εντοπισμός σφαλμάτων του CUDA C/C++ και κώδικα DirectCompute κατευθείαν στο υλικό GPU
\item Χρήση των γνωστών εργαλείων του Visual Studio όπως Watches, Memory, Locals, και Breakpoints.
\item Συσχέτιση των δραστηριοτήτων OpenCL, CUDA, Direct3D, OpenGL με την ακριβή γραμμή κώδικα.
\item Ειδικές σελίδες έκθεσης με στατιστικά και καταγραφές των κλήσεων API.
\end{itemize}

Παράδειγμα χρήσης του Νvidia Nsight φαίνεται στην παρακάτω εικόνα.
\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{IDEs/VISUAL-STUDIO}
\caption{Παράδειγμα χρήσης Nvidia Nsight σε συνδυασμό με Visual Studio}
\end{figure}
